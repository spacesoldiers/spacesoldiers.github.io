<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javascript垃圾回收机制(GC)]]></title>
    <url>%2F2016%2F07%2F25%2Fjavascript-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[垃圾回收机制—GC 程序运行一定会涉及到内存的申请与释放和Java,c#一样，JavaScript也有垃圾回收的机制，早期的 C 语言( C++ )都手动的控制内存的申请与释放。在计算机中的内存不是一个固定, 属于 “流动型” 内存( 例如 公交车的座位 )，内存的管理决定了程序的运行效率。内存如果是连续的, 程序的运行效率高, 内存如果出现很多碎片, 程序运行的性能就低。 js 中凡是涉及到对象的时候 就会申请内存创建对象，调用函数，等操作都会涉及到申请内存。但是函数的内存由系统进行管理，一旦调用结束内存回收。但是对象的内存由 js 引擎进行管理，js 中对象具有动态特性，所以 js 引擎都会带有垃圾回收机制。垃圾回收做两件事儿，一个是释放不使用的内存， 二是整合内存。结论, 进行垃圾回收的时候, 会影响程序的性能 js 怎么进行回收, 什么时候进行回收呢?JavaScript垃圾回收的机制很简单：原理就是找出那些不再继续使用的变量，然后释放其占有内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。借用高程里面的一句话，你只需要记住 js 一定会回收，你相信它即可。在 js 中凡是不使用的对象才会被回收。var obj = {};在代码运行的过程中, 假设浏览器不关闭. 那么 这个对象( 右边的那个 ) 就不会被回收.如果代码运行了这么一句话:obj = null;那么这个对象就不再被引用着( 如果没有任何变量指向它 ), 这个对象就可以被回收。但是如果在 obj = null 之前执行了一句话 var newObj = obj，那么 obj 不再指向这个对象,但是 newObj 指向了这个对象, 即它不是 “幽灵”，这个对象依旧不会被回收。 常见的垃圾回收算法垃圾回收算法需要弄明白的问题有两个，一个是回收什么内存，二是什么时候回收 如何标记内存 引用计数法凡是对象, 在内存中会引用一个 count 指标, 如果对对象进行引用, 那么 count 就会自动 +1例如: 12345new Object(); // 此对象的 count 为 0 var o1 = new Object(); // 此对象的 count 为 1 var o2 = o1; // 该对象的 count 加 1，变为 2 o1 = &#123;&#125;; // 这个新对象的 count 为 1，原来的那个对象为 1 o2 = null; // 此时新对象的 count 还是 1，原来的那个对象就是 0 了，那么 它就可以释放了。 标记法凡是创建的对象都会获得一个标记，表示被引用者。在代码的运行机制中每一个变量会被创建一个索引，记录在系统的内部，可以类比成字典的索引。如果要进行回收，会遍历所有的变量索引，对应的去找这个对象在哪里，如果找到了对应的对象给对象加一个标记。如此遍历以后，我们的所有的对象就含有了对应的标记。在遍历对象所在的内存，将没有对应标记的对象找出来，表示这个内存可以被回收。 什么时候回收 定值域法在内存的使用过程中会监视每一个对象所占内存，以及总内存。会实时的与值域进行比较， 如果当这个数据超过了我们的值域，那么就会触发垃圾回收。 动态值域法给定上下限，同时监视程序的密集度。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的基本用法]]></title>
    <url>%2F2016%2F05%2F13%2Fgit%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git 是分两部分的, 一个是远程仓库, 一个是本地仓库 本地仓库基本步骤 需要配置用户信息 12git config --global user.name "用户名"git config --global user.email "邮箱" 这是配置全局用户名和邮箱，在当前计算机中，创建的项目仓库均默认使用该用户名和邮箱。 如果希望配置当前项目使用的用户名和邮箱，其他项目不使用这个，可以局部配置。 12git config user.name "用户名"git config user.email "邮箱" 局部配置的前提是先创建本地仓库 初始化仓库 1git init 初始化仓库以后，会在当前目录下创建一个.git的隐藏文件夹，这个文件夹就是备份的地方。局部配置的用户信息会存储到.git文件夹中，而全局配置的数据会存储到家目录中。 在git中只会管理文件，不会管理文件夹 1git status 查看当前git的状态 在代码中使用命令 1git add . 将当前文件夹(.)中的所有文件加入到管理的缓存中 使用命令 1git commit -m "提交信息" 将缓存中的代码一次性存储到仓库里 查看提交日志 1git log 说明 使用git status来查看git的状态可以了解到git当前的工作环境 使用git add添加到缓存的时候，可以使用语法git add -A或git add 文件名 文件在编辑修改的时候会有很多种操作，在提交之前应该使用git status检查一下是否在缓存中，如果不在add一下 在提交的时候如果没有提供-m参数，则会进入vim编辑器，如果提供了提交内容并保存退出，则该提交成功，如果没有提供任何提交信息直接退出编辑器，则该提交终止。 注意：对于复杂的修改建议使用vim编辑器提供提交日志，并使用下面的格式 第一行：一句话简要概括修改内容 第二行：空行 第三行：详细描述每一个修改的部分与其他信息 在提交之后使用git log查看的时候，提交日志会完整的显示出来，也可以只显示部分，使用命令 12git log --pretty=short git log --oneline 仓库的原理概述 使用git是将代码进行了备份，备份到了仓库中 我们在创建仓库的时候git init，实际上就已经将仓库存储到当前文件夹中了，隐藏的.git文件夹就是仓库所在的文件夹 git将我们的项目文件夹分成了三个部分：工作区、暂存区和仓库。当前文件夹中，.git文件夹中包含暂存区和仓库，它是隐藏的文件夹，这就意味着不希望我们使用该文件夹，.git文件夹外就是工作区，我们在工作区编写代码、创建文件。 我们在git add后，文件就进去了暂存区，git commit后，文件就存储到了仓库。 .gitignore文件 该文件用于过滤不提交的数据 在开发中我们会用到第三方的库，在备份的时候，如果将第三方的库也备份起来，会增加我们服务器存储的压力，所以有时我们会考虑将一部分代码上传，而有些代码不上传。 .gitignore文件里面编写的东西就是不备份的文件和文件夹的路径，如果希望一个文件夹test不备份，只需要在.gitignore文件中写上test，如果src文件夹下的app.js文件不备份，只需要在.gitignore文件中写上src/app.js注意：在windows下创建.gitignore文件，要么使用命令，要么创建文件的时候在结尾处加上“点”。1touch .gitignore 分支所谓的分支，就是在一个版本控制列表中分离出来一个平行的独立的备份列表，这个新的备份列表与以前的那个备份列表的操作一模一样，但是两者独立应用场景： 代码编写中发现有新的算法，可以创建一个分支，编写新的代码。如果出现问题删除分支即可，不影响原始代码。如果算法成功，合并分支即可将新算法衔接到当前项目中。 代码编写中发现bug，使用分支来修改bug，修改完成后合并当前分支。 团队开发过程中，每个程序员负责一个分支，在功能实现后合并分支，各个程序员互不影响。 项目上线后，对项目扩展、修复bug等，创建分支，在分支上进行操作，从而不影响线上项目的运行。 在git中，默认有一个分支，即master分支(主分支)。查看分支使用命令：1git branch 创建分支使用:1git branch 分支名 切换分支:12# 在哪一个分支上进行开发，就要先切换到该分支上git checkout 分支名 将某分支合并到master分支中： 先切换到master分支 执行合并分支命令：1git merge 分支名 删除分支：1git branch -d 分支名 冲突冲突就是在多人写作的时候，或分支合并的时候，如果一个文件被两个操作修改，并同时保存到仓库中就会出现冲突。git在合并或保存的时候，如果文件出现了冲突，会同时保存两个版本的代码，并抛出一个错误，在命令行中爆出confilect提示，要求进行修改后再重新提交。 远程仓库远程仓库顾名思义就是仓库存储在其他计算机中。我们将项目备份到仓库中。下载项目：1git clone url 下载到该项目后，正常的操作项目文件，git add，git commit即可，如果要提交，使用:1git push 下载数据到本地：1git pull 生成秘钥：1ssh-keygen -t rsa 常用的远程仓库：github oschina coding gitlib]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大前端学习路线]]></title>
    <url>%2F2016%2F04%2F25%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[第一阶段：基础教程HTML+CSS: HTML进阶、CSS进阶、div+css布局、HTML+css开发 JavaScript基础： js基础教程、js内置对象、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器 JS基本特效： 常见特效：tab栏切换、导航、整页滚动、轮播图、手风琴菜单、瀑布流布局、滚动事件… JS高级： 正则表达式、排序算法、递归算法、闭包、作用域链、面向对象基础… JQuery：基础使用 DOM操作、特效和动画、方法链、JQueryUI组件基本使用… 第二阶段：HTML5和移动Web开发HTML5： HTML5新语义标签、html5表单、音频和视频、离线和本地存储、canvas. CSS3: CSS3新选择器、伪元素、边框、阴影、background系列属性、transition、动画、3D效果制作、velocity.js、css3网页制作 Bootstrap: 响应式概念、媒体查询、响应式网站制作、删格系统、Bootstrap常用模板、LESS和SASS 移动Web开发： 跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、zepto.js 第三阶段：HTTP服务和AJAX编程WEB服务器基础： 服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍 PHP基础： PHP基础语法、使用php处理简单的GET或者POST请求 AJAX： Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用 JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、jQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额 第四阶段：面向对象面向对象三大特征： 抽象性、继承性、多态性、封装性 设计模式： 面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程 第五阶段：框架封装框架封装基础： 事件冒泡、捕获、事件对象 框架封装中级： 运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装 框架封装高级和补充： jquery框架雏形、可扩展性、模块化、封装属于传智自己的框架 第六阶段：模块化组件开发面向组件编程： 面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。 面向模块编程： AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS 第七阶段：主流框架Web开发工作流： Git/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack MVC/MVVM/MVW框架： Angular.js、Backbone.js、Knockout/Ember 常用库： React.js、Vue.js、Zepto.js。 第八阶段：HTML5原生移动应用开发Cordova： WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。 Ionic： Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。 React Native： react Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。 HTML5+： Html5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。 第九阶段： Node.js全栈开发：快速入门： Node.js发展、生态圈、Io.js、Linux/Windows/OS X环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试核心模块和对象： 全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端、Socket.IO Web开发基础： HTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例 快速开发框架： Express简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>学习目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript作用域和闭包]]></title>
    <url>%2F2015%2F09%2F03%2Fjavascript-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[作用域什么是作用域变量起作用的范围就叫作用域 块级作用域使用代码块限定的作用域就是块级作用域，js中的作用域是函数级的，没有块级作用域 作用域链只要是函数都有作用域，函数内部的作用域可以访问函数外部的作用域，当多个函数嵌套的时候，就会形成一个链式的结构，这就是作用域链。 词法作用域js中的作用域叫词法作用域在代码写好的时候，就能确定变量的作用域，这种作用域就是词法作用域 变量提升js中代码的运行分两个阶段 预解析阶段 变量名和函数提升 将var声明的变量名和function开头的函数提升到当前作用域的最上面 执行阶段 从上到下逐句执行需要注意的地方： 变量和函数同名的时候,只提升函数，忽略变量名 函数同名的时候,都提升，但后面的函数会覆盖前面的函数 函数表达式,只会提升变量名，不会提升后面的函数 变量提升只会将变量和函数提升到当前作用域的最上方 变量的搜索规则 首先在访问变量的作用域中查找，如果找到直接使用 如果没找到，到上一级作用域中查找，如果找个直接使用 如果没找到，继续到上一级作用域中查找，直到全局作用域 如果找到了就用，没有找到就报错 闭包闭包是什么一个封闭的不对外公开的包裹结构或空间，js中的闭包就是函数 闭包的作用如果把数据放在全局作用域内，那么所有人都可以随意修改，这个数据就不再可靠。闭包可以创建一个私有空间，在这个空间内部的数据，外部无法直接访问。外部空间想要访问函数内部的数据，只能通过闭包提供的指定的方法，在这个方法内部可以设置一些校验规则，让数据变得更加的安全。 闭包要解决的问题 在函数外部访问不到函数内部的数据 要解决的问题就是需要在外部间接的访问函数内部的数据 闭包的基本结构123456function outer()&#123; var data = "数据"; return function()&#123; return data; &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript原型和原型链]]></title>
    <url>%2F2015%2F08%2F19%2Fjavascript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[什么是原型？对于初学者，javascript的原型是一个让人困惑的问题，各种指向很容易让人混淆。想要了解什么是原型，那么先来了解函数。在js中，函数是一等公民，它既能像传统函数一样调用，又能像值一样传参、返回，同时还可以是类的构造函数，又是Function的实例，别看它有这么多的身份，但它就是一个普普通通的引用类型，仅仅是一个代码执行的模板。 凡是函数，背后都有一个对象存在这个对象可以通过该函数的prototype属性来访问，默认情况下这个对象含有一个属性constructor，用于指回该函数。也就是说，如果一个对象含有constructor属性，同时它指向某一个函数，那么就表示这个对象是这个函数背后的prototype。 prototype的特征函数的prototype指向的这个对象，里面的所有成员（属性、方法）都会默认的链接到这个函数作为构造函数时创建的对象上。也就是说，创建对象的时候：构造函数、实例对象与神秘对象之间就构成了某种联系，这就是实例原型三角形，如下图所示： 结论：这个神秘对象在构造函数角度来看，是利用prototype属性获得到的，因此将其称为构造函数的原型属性，简称原型。如果站在实例对象和这个神秘对象的角度来看，神秘对象被称为实例对象的原型对象，简称原型。实例对象可以直接访问原型对象的成员，称为原型式继承。 什么是原型链凡是构造函数就有原型属性，凡是实例对象就有原型对象，原型也是对象，所以原型也有原型，原型的原型也有原型，直到…? 在javascript设计的时候，将原型的顶端设计为Object.prototype,任何一个默认的、内置的函数的原型都继承自Object.prototype。例如：创建一个数组，数组继承自Array.prototype，而Array.prototype继承自Object.prototype。创建一个函数function Person(){}，此时，Person的实例继承自Person.prototype，Person.prototype就继承自Object.prototype。因此在js的对象结构中出现了一系列原型对象，将这一系列原型对象称为原型链。 原型对象和Object构造函数的关系在js中，函数也是对象，而对象又是构造函数创建出来的，那么函数的原型是哪个构造函数创建的呢？我们可以分析一下，所有函数的原型都继承自Object.prototype，而Object.prototype是Object的原型，因此根据原型三角形理论，我们可以推断函数的原型就是Object创建出来的，他们之间的关系应该是下面这样的：Person、Person实例和Person.prototype构成一个原型三角形Person.prototype、Object和Object.prototype又构成了一个原型三角形 Function和Object函数之间的关系我们都知道函数是Function的实例，所以很容易知道函数、Function和Function.prototype之间的三角形关系，重点在于，函数是Function的实例，而Function也是函数，所以得出一个非常狗血的结论：Function是Function自己的实例（shit），因此它们之间的关系可以用下图表示：Function实例继承自 Function.prototypeFunction.prototype 继承自 Object.prototypeObject.prototype 往上就是nullObject作为Function的实例继承自 Function.prototypeFunction.prototype 继承自 Object.prototypeObject.prototype 往上就是null Function, Object, 以及自定义函数的完整原型链终于到了最后一步了，根据上面我们的分析，最后的完整原型链图也就可以画出来了，但我的画图水平太烂了，凑合着看吧！ __proto__ 属性忘了说一下这个属性了，这里补充一下，其实__proto__并不是js的标准属性，最早是火狐在浏览器中引入的，其目的是利用实例对象观察其原型的结构。早期没有 __proto__ 的时候，为了观察对象的继承关系，必须通过 实例.constructor.prototype来获得实例对象的原型对象。在分析过程中非常麻烦,因此在火狐浏览器中给实例对象引入了__proto__ 属性，用于快速的访问该实例的原型对象。该属性带有双下划线，表示内部属性，后来各大浏览器也效仿引入该属性，从而利用实例也可以访问原型对象了。但并不是所有浏览器都实现了该属性，如果浏览器不支持，我们也可以自己实现该功能：123Object.prototype.__myProto__ = function ()&#123; return this.constructor.prototype;&#125;; 相关小知识点 属性搜索原则对象在访问某一个成员的时候( 属性，方法 )，会在当前对象中查找是否含有该成员，如果有该成员直接使用，停止查找;如果该对象中没有对应的成员，就会到其原型对象中查找，如果其原型对象中含有该成员，直接使用，停止查找;如果原型对象中任然没有该成员，继续向原型的原型中查找… 如此往复，直到Object.prototype，如果还没有该成员，就会返回 undefined。如果给对象设置成员( 属性或方法 )，都是在当前对象上进行设置。 instanceof 运算符语法:对象A instanceof 函数B含义：对象A如果是被函数B new出来的，那么就返回true，否则返回false。这只是表面的含义，它的深层含义应该是：如果函数B的prototype属性所指的对象在对象A的原型链上，那么就返回true，否则返回false。举个典型的例子：1234console.log( Function instanceof Object );//trueconsole.log( Object instanceof Function );//true//Object.prototype 在不在 Function 的原型链上呢? 在，所以返回 true//Function.prototype 在不在 Object 的原型链上呢? 在，所以返回 true]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的继承]]></title>
    <url>%2F2015%2F05%2F23%2Fjavascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[在js中代码的技巧，应该来说比其他语言更加有意思，因为它的灵活性太大了，其中最典型的就是继承，js中继承的实现方式有很多种，今天就来介绍几种简单的继承。 原型式继承：这种继承方式比较好理解，原型有的，实例就有。原型继承也就是在原型中添加成员，实例对象就可以直接使用该成员，即实现了原型继承，重点就变成了怎么给原型添加成员，常用方式有两种 利用对象的动态特性给原型添加成员 1234Person.prototype.sayHello = function () &#123;&#125;;Person.prototype.run = function () &#123;&#125;;Person.prototype.eat = function () &#123;&#125;;Person.prototype.walk = function () &#123;&#125;; 直接替换原型对象 1234567Person.prototype = &#123; constructor: Person, sayHello: function () &#123;&#125;, run: function () &#123;&#125;, eat: function () &#123;&#125;, walk: function () &#123;&#125;&#125;; 注意：这个方法实际上是更换了原型对象，继承关系发生了改变例如：123function Person() &#123;&#125;var p1 = new Person();//继承关系：p1--&gt;原来的原型(Person.proto)--&gt;Object.prototype--&gt;null 1234567//替换原型对象Person.prototype = &#123; constructor: Person, sayHi: function () &#123;&#125;&#125;;var p2 = new Person();//继承关系：p2--&gt;新的原型(含有sayHi方法的原型)--&gt;Object.prototype--&gt;null 混入式继承这种方式是比较有争议的一种继承，是最不像继承的继承，它的原理是将对象a中的每一个成员加到对象b中，那么对象b就继承自对象a，代码实现如下123456789101112131415function extend( dest, objs ) &#123; for ( var i = 0; i &lt; objs.length; i++ ) &#123; for ( var k in objs[ i ] ) &#123; if ( objs[ i ].hasOwnProperty( k ) ) &#123; dest[ k ] = objs[ i ][ k ]; &#125; &#125; &#125;&#125;//该代码有多种变体function extend( obj ) &#123; for ( var k in obj ) &#123; this[ k ] = obj[ k ]; &#125;&#125; 通过代码，我们可以看出，它就是一个copy的过程，将一个对象中的成员复制给另一个对象，从而达到继承的目的。 组合继承组合继承就是把多个继承方案混合到一起使用以原型继承与混入继承为例，一般书写构造函数的时候都是这么实现的:1234567891011121314151617181920212223242526272829303132//1. 写一个构造函数function Person(name,age,gender)&#123; this.name = name; this.age = age; this.gender = gender;&#125;//2. 准备一个原型Person.fn = Person.prototype;//3. 准备一个混入方法Person.fn.extend = function(obj)&#123; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; this[key] = obj[key]; &#125; &#125;&#125;//4. 在原型中混入多个成员Person.fn.extend(&#123; sayHello:function()&#123; console.log('你好，我是'+this.name+'今年'+this.age+'岁，我是'+this.gender+'生'); &#125;, sayHi:function()&#123; console.log(this.name+this.age+this.gender); &#125;, eat:function()&#123; console.log('今天吃大餐'); &#125;&#125;)//5. 使用构造函数创建对象，对象就有多个方法了var p = new Person('jack',18,'女');p.sayHello();p.eat(); 标准继承语法：Object.create(对象)返回一个新对象，将create方法参数中的对象作为原型，例：12345var p = &#123; name:'jim'&#125;var obj = Object.create(p);//继承关系：obj--&gt;p--&gt;Object.prototype--&gt;null 早期的js并没有提供继承的语法，这种继承的方式是道格拉斯(js语言精粹的作者)在ES3时代给出的实现继承的方法，他给出了如下函数：12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 在object()函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。ES5中将这个方式标准化了，新增了Object.create()方法，也就是所有支持ES5+的浏览器都含有Object.create()方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5新增数组方法]]></title>
    <url>%2F2015%2F05%2F12%2FES5%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[遍历方法forEach作用：遍历数组中的每一个元素，并且将数组的每一个元素作为参数传入到回调函数中，让回调函数来处理我们的数据。模拟forEach方法：我们对数组进行遍历，实际上对数组的处理有很多，但是所有的逻辑其实都包在for语句中间12345678910111213for ( var i = 0; i &lt; arr.length; i++ ) &#123; // 只要是对数组进行操作, 就是在对 arr[ i ] 和 i 在进行操作 // 而且所有的逻辑不会改变 for 循环的这个结构, 不同的是在 for 中间的代码&#125;//因此我们直接引入回调函数function myEach(arr,callback)&#123; for( var i = 0;i &lt; arr.length;i++ ) &#123; callback(arr[i],i); &#125;&#125;//例：实现求和var sum = 0;myEach( arr,function(v)&#123; sum += v; &#125;); map翻译过来叫：映射（地图），作用是将数组中的每一个元素，按照某一个规则变成另一个元素，构成一个新数组。例如：数组[1,2,3] –&gt; 规则扩大两倍 –&gt; [2,4,6]。在代码中来实现这个功能，采用的是循环，因为要处理每一个元素。因此会遍历数组中的每一项。map会为每一个数组项调用回调函数，同时记录回调函数的返回值，从而构成新的数组。模拟map方法：12345678function map( arr, callback ) &#123; var ret = []; for ( var i = 0; i &lt; arr.length; i++ ) &#123; var item = callback( arr[ i ], i ); ret.push( item ); &#125; return ret;&#125; filter在数组中筛选元素，也是对数组的每一个元素用回调函数来处理，回调函数返回boolean值，表示这个元素是否符合要求，filter方法会将所有符合要求的数据，组成一个新的数组返回。例如：12345var arr = [2,4,1,6,8,9,10];//获取所有偶数项arr.filter( function ( v ) &#123; return v % 2 == 0;&#125; ); some与everysome是遍历数组中的每一个元素，利用回调函数处理每一个元素，并判断元素是否符合规则，回调函数返回boolean值，表示是否符合要求。 some表示这个数组中只要有一个满足规则就返回true。例：arr.some( function ( v ) { return v &gt; 3; });判断数组中有没有比3大的谁数字，只要有一个比3大就返回true。 every 判断每一项是否满足要求，必须是的每一个都满足才会返回true，否则只要有一个不满足，就会停止遍历，返回 false。 reduce和reduceRightreduce 从数组起始位开始遍历reduceRight 从数组末尾开始遍历 注：在这些数组遍历方法中，回调函数有第三个参数，方法一般也有第二个参数，回调函数的第三个参数是数组本身，方法的第二个参数用于描述回调函数中的this，回调函数中的this默认是指全局对象window，如果方法提供了第二个参数，那么this就是这个对象。 indexOf和lastIndexOf在ES3中，字符串就已经具备了这两个方法，作用是检索指定字符串值在字符串中首次出现的位置，如果没有返回-1.而现在数组的这两个方法和字符串方法的功能一致，检索指定项在数组中首次出现的位置，没有返回-1。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript面向对象]]></title>
    <url>%2F2015%2F05%2F10%2Fjavascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象面向对象是一种编程的范式（一种思维模式） javascript是基于对象的多范式编程语言。 所谓的基于对象，表示其如果没有对象就什么事情也做不了，而且js内置了多个对象。 所谓的多范式，是指多种编程的思维模式，例如面向过程式编程，面向对象编程，函数式编程等。 面向过程的含义是指你需要注重其步骤，顺序，以及每一个细节，面向对象是指我们不需要关注每一个细节步骤顺序，我们只需要找到对象，发出命令，等待结果。但面向过程是基础，并非面向对象就很好，不用学习面向过程。 函数式编程将所有的操作以函数的形式呈现，所有操作顺序以函数的递归，嵌套，回调与链式调用的形式展开。 培养利用面向对象的方式思考问题 当我们拿到一个需求的时候，应该考虑的是这个问题应该涉及到哪些对象。 在代码中我们所描述的对象应该更加具体一点：在js中就是键值对。我们使用对象来模拟实际的操作，对象用于描述其自身的特征所使用的变量称为对象的属性，对象的行为称为对象的方法。如果我们利用对象来进行开发，即要写一个对象，其实就是在写它的属性和方法。 怎么写对象？抽取：对象中与该项目有关的信息例如要实现俄罗斯方块这个游戏，首先关注有什么对象对象：方块，舞台将方块这个对象进行细化: 正方形, 条形, 左 z 形, 右 z 形, …需要描述每一个图形的边界, 这就是方块对象的属性为了区分不同的方块, 会在移动的过程中添加颜色, 颜色也是方块的属性移动的速度也是方块具有的特征, 自然也是它的属性每一个方块可以进行旋转, 左移, 右移, 下落. 这些就是方块的行为在操作过程中方块还需要有一些特征就是坐标舞台这个对象, 舞台就是容器, 里面需要提供的特征, 宽度, 高度, 以及底的每一个方格这个舞台应该有一个计时器, 实时运行判断下面的方块堆满了没有如果满了还要考虑消掉指定方块其实可以使用如下数组来描述:1234[ [ 0, 1, 1, 1, 1, 1, 0 ], [ 1, 0, 1, 1, 0, 0, 1 ], [ 1, 0, 1, 1, 1, 1, 0 ]] 怎么编写对象 使用字面量js中最简单的对象写法就是使用字面量，写法就是一个花括号，里面跟上用冒号链接的键值对，每一个键值对用逗号分隔，键值对中，值如果为非函数，则称其为属性，如果值为函数，就是方法。1234var o = &#123; name: 'jim', sayHi: function()&#123;&#125;&#125; 使用字面量描述对象有一些缺点：无法复用。 工厂设计模式（factory）所谓的工厂设计模式就是创建一个创建对象的函数，凡是要对象的时候，就调用该函数，这个函数即工程函数，例：12345function createFood()&#123; var food = &#123;&#125;; food.xxx = value; return food;&#125; 在使用工厂作为创建对象的手段时，有几个名字是固定的，一个是create，一个是factory。 利用构造函数创建对象使用new来创建对象，将对象传递给构造函数的this，在构造函数中给对象进行初始化。123456789function Food() &#123; this.x = 10, this.y = 20, this.color = 'red', this.backgroundImage = './123.jpg', ...&#125;//在构造函数中约定了我的对象应该具有什么成员var food = new Food(); // 创建对象 小结：在实际开发过程中如果是简单的形式处理对象，而不需要考虑复用，直接使用字面量如果对象比较复杂，可以考虑使用工厂如果需要考虑继承等其他面向对象的特征，就应该使用构造函数 js中包装对象包装对象：Number,String,Boolean由于js的基本类型不是对象，为了让它们可以方便操作，设计了包装对象来提供各种方法。在代码执行过程中，如果需要使用方法，会在代码中临时创建对应的对象，调用方法后释放该对象。例如：1'abcdfg'.split('') 利用字符串先创建一个String的实例new String(‘abcdfg’); 调用这个实例对应的split方法，分隔字符串，返回一个数组； 在返回数组在之后，释放该对象。如果要取得对应包装对象中存储的值，使用valueOf方法。 面向对象特征 抽象性其原意是说从事物上抽取你需要的特征，然后将这些特征组合起来表示这个具体的事物，鸭子辨型：如果你像鸭子一样走路和嘎嘎的叫，那么你就是鸭子。数据在确定环境之前无法准确描述，你像你就是。 封装性封装性就是讲复杂的逻辑，或需要隐藏的数据保护起来，不让使用者看到了解到，只预留简单的接口供使用。比如函数，就是封装的体现。 继承性拿来主义，自己原来是没有的，别人有，拿来成为自己的。 多态性js中的多态比较不容易理解，和其他语言不太一样。原意：一个对象调用同一个方法，会展示出不同的效果。多态的模型：一个变量，被赋值给不同的对象，由于每一个对象是独立的个体，具有不同的实现逻辑，因此使用这个变量调用同一个方法会得到不同的效果。实际场景：一家公司要存储公司的一些业务数据，首先考虑的是免费的MySQL数据库，随着公司的不断扩大，需要更换Oracle数据库，那么就出现了问题，以前操作MySQL的所有api无法使用了，现在考虑为Oracle重新编写api1234567891011121314//假设操作MySQL使用下面的对象var mysql = &#123; selectByMySQL: function () &#123;&#125;, insertByMySQL: function () &#123;&#125;, deleteByMySQL: function () &#123;&#125;, updateByMySQL: function () &#123;&#125;&#125;//使用下面代码操作 Oracle 数据var Oracle = &#123; selectByOracle: function () &#123;&#125;, insertByOracle: function () &#123;&#125;, deleteByOracle: function () &#123;&#125;, updateByOracle: function () &#123;&#125;&#125; 我们如果在更换任何数据库的时候，考虑将代码全部重写，这个是不科学的，可以考虑在所有的数据操作部分加一个层，在中间提供一个数据操作抽象层123456var db = &#123; select: function () &#123;&#125;, insert: function () &#123;&#125;, delete: function () &#123;&#125;, update: function () &#123;&#125;&#125;; 但这些方法全部是空方法，没有方法体，调用后没有任何效果改写MySQL与Oracle的数据操作方法，与抽象层的方法名一样12345678910111213141516171819202122232425262728var db_mysql = &#123; select: function () &#123; return mysql.selectByMySQL(); &#125;, insert: function () &#123; return mysql.insertByMySQL(); &#125;, delete: function () &#123; return mysql.deleteByMySQL(); &#125;, update: function () &#123; return mysql.updateByMySQL(); &#125;&#125;var db_oracle = &#123; select: function () &#123; return oracle.selectByOracle(); &#125;, insert: function () &#123; return oracle.insertByOracle(); &#125;, delete: function () &#123; return oracle.deleteByOracle(); &#125;, update: function () &#123; return oracle.updateByOracle(); &#125;&#125; 在实际开发的业务逻辑中使用db对象操作数据：如果公司要求使用MySQL 数据库db = db_mysql;如果公司要使用 Oracle 数据库db = db_oracle;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题配置（二）]]></title>
    <url>%2F2015%2F04%2F11%2Fnext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[引入第三方服务添加站内搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑根目录下的配置文件_config.yml，新增下面的内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 在next主题配置文件中启用本地搜索功能： 1234# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true 添加百度统计 登录 百度统计，注册站长账号，填写网站域名和网站首页，注册完成后并登陆。 复制 hm.js? 后面那串统计脚本 id,如下图所示： 在站点blog/_config.yml中修改字段 baidu_analytics，值设置成你的百度统计脚本 id。 添加网易云音乐就我所知目前也就网易云音乐和虾米音乐的外链播放器能用，网易云音乐很多好听的歌曲都不能生成外链，提示说是由于版权问题无法生成外链，而虾米音乐播放器外观实在是太那个了，所以只能用网易云音乐了，有些中文歌曲还是可以生成外链的。 首先进入官网后，搜索你要的歌曲，打开歌曲页面后左边唱盘图片下面有个“生成外链播放器”点进去，进去后可以看到有iframe和flash两种网易云音乐插件代码，还可以自定义播放器尺寸和自动播放。 将获得的html代码插入到你想要插入的位置。 我放在了侧边栏中，所以在next\layout\_macro\sidebar.swig文件中插入html代码即可 添加鼠标点击出现桃心下载love.js，将love.js文件放到next/source/js/src/文件夹中，在next/layout/_layout.swig文件的最下面引入即可:1&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题配置(一)]]></title>
    <url>%2F2015%2F04%2F11%2Fnext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%B8%80%2F</url>
    <content type="text"><![CDATA[本文只分享此博客的一些配置，对于node.js和github的安装可自行搜索，网上有很多教程。废话不多说，直接上代码。 基本配置：所需环境 Node 环境、 npm 全局安装 、github 账号 安装Hexo1234$ npm install hexo-cli -g #下载hexo$ hexo init blog #初始化$ cd blog$ hexo server #启动本地服务 此时打开浏览器，输入：http://localhost:4000/就能看到我们的博客了，但目前只有本机能看到，我们还需要将博客部署到github上：1$ hexo d -g 部署完成后输入我们的网址就可以访问了，如：spacesoldiers.github.io注意：每次修改博客内容后要重新部署。 next主题下载在blog根目录下执行：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载完成后，打开根目录下的配置文件_config.yml，找到 theme 字段，并将其值更改为 next theme: next 修改语言为中文：找到language字段 language: zh-Hans 选择schemeNext提供三种不同的外观，可以通过主题配置文件_config.yml更改外观，注意这是next主题文件夹里的文件，不是根目录配置文件。找到scheme字段，将需要使用的scheme前面的注释 # 去掉 # Schemes # scheme: Muse # scheme: Mist scheme: Pisces 设置菜单通过修改next主题下的_config.yml的menu字段，选定显示的菜单项。 menu: home: / categories: /categories/ archives: /archives/ about: /about/ #tags: /tags/ #sitemap: /sitemap.xml #commonweal: /404.html 添加菜单页面Next主题默认有home首页和archives归档页，因此新添加的菜单项需要新建菜单页面在根目录下输入命令：1$ hexo new page categories #添加分类页 在blog/source下会新生成一个新的文件夹categories，在该文件夹下会有一个index.md文件，添加内容type: &quot;categories&quot;12345---title: tagsdate: xxxx-xx-xxtype: "categories"--- 要为某一篇文章添加分类，只需在blog/source/_post目录下的具体文章的categories中添加分类名称即可，如：12345---title: "前端学习路线"tags: "学习路径"categories: "前端"--- 其他菜单页的添加同理，这里不再一一介绍。 头像设置在next主题文件的source/images/下放置头像文件avatar.gif即可 设置favicon.ico将设计好的图标放入source/images/文件中，在主题配置文件中找到favicon字段 favicon: images/favicon.ico 设置代码主题NexT共有5款代码主题供你选择，更改 highlight_theme 字段，将其值设定成你所喜爱的主题 # Code Highlight theme # Available value: normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: normal 自定义css样式是否觉得主题的某些样式不符合自己的心意，不用担心，next的设计还是很人性化的，你可以自己定义喜欢的样式，你所有的css改动需要放在主题文件的source/css/_costum/costum.styl文件中，会覆盖原来的css，这样比你修改源文件要好的多，不想用时只要删除掉costum.styl里面自己写的代码，就会回到原来的样子。 添加logo图片可以从网上免费设计一个logo图片，存放到source/images/文件夹中，在costum.styl中给.site-meta .brand添加背景图片样式即可，如：1background-image: url(&quot;/images/logo.png&quot;); 去除底部copyright将主题配置文件中的copyright字段值改为false即可。12# Footer `powered-by` and `theme-info` copyrightcopyright: false 添加页面加载动画next配置文件中有很多种页面加载动画可供选择，找到pace字段改为true，然后选择一个自己喜欢的样式：12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-bounce 自定义菜单栏动画由于next主题已经引入了velocity.js，所以直接用它的动画就可以了，找到next/layout/_layout.swig，在body最下面添加代码:12345&#123;% if theme.menu_move.enable %&#125; &lt;script&gt; $(".menu-item").stop(true).velocity("transition.slideLeftBigIn", &#123; stagger: 200 &#125;); &lt;/script&gt;&#123;% endif %&#125; 在主题配置文件中加入字段menu_move:12menu_move: enable: true 配置完成后发现自定义动画结束后，还会执行一次动画，那是因为菜单栏有自带的动画，这里需要去除一下，找到next/source/js/src/bootstrap.js，将第31行和第37行注释掉即可：12// NexT.utils.addActiveClassToMenuItem();// .add(NexT.motion.middleWares.menu)]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java继承特性]]></title>
    <url>%2F2014%2F09%2F20%2Fjava%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承的作用： 提高了代码的复用性。 让类与类之间产生了关系，有了这个关系，才有了多态的特性。 Java语言中，只支持单继承，不支持多继承 多继承容易带来安全隐患：当多个父类中定义了相同功能，功能的内容不同时，子类对象不确定要运行哪一个。但是Java保留了这种机制，并用另一种体现形式来完成表示：多实现。 Java支持多层继承，也就是一个继承体系。想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系中的共性功能，通过了解共性功能，就可以知道该体系的基本功能。那么这个体系就已经可以基本使用了。在具体调用时，要创建最下层子类的对象，为什么呢？一是因为有可能父类不能创建对象。二是创建子类对象可以使用更多的功能，包括基本的也包括特有的。简单一句话：查阅父类功能，创建子类对象。 子父类出现后，类中成员的特点：变量 如果子父类中出现非私有的同名成员变量时 子类要访问本类中的变量，用this，代表本类对象的引用 子类要访问父类中的同名变量，用super，代表父类对象的引用 子父类中的函数当子类中出现和父类一模一样的函数时，子类对象调用该函数，会运行子类中的函数，如同父类的函数被覆盖一样。这种情况是函数的另一个特性：重写（覆盖）。当子类继承父类，沿袭了父类的功能到子类中，但是子类虽具备了该功能，但是功能的内容却和父类不一致，这时没有必要定义新功能，而是使用覆盖特性，保留父类的功能定义，并重写功能内容。重写（覆盖）注意事项： 子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败。 静态只能覆盖静态。 成员变量、静态方法不能被重写（覆盖） 被覆盖的方法只有覆盖它们的类才能访问。 子父类中的构造函数在对子类对象进行初始化时，父类的构造函数也会运行，这是因为子类的构造函数默认第一行有一条隐式的语句super();super();会访问父类中空参数的构造函数，而且子类中所有的构造函数默认第一行都是super();为什么子类一定要访问父类中的构造函数呢？因为父类中的数据子类可以直接获取，所以子类对象在创建时，需要先查看父类是如何对这些数据进行初始化的，要先访问一下父类中的构造函数。如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。注意：super语句一定要定义在子类构造函数的第一行。super只有子类能用。 子类的实例化过程结论：当父类中没有空参数的构造函数时，子类必须手动通过super语句来指定要访问的构造函数。当然子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java继承</tag>
      </tags>
  </entry>
</search>
