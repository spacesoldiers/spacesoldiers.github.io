<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java继承特性]]></title>
    <url>%2F2016%2F09%2F10%2Fjava-jc%2F</url>
    <content type="text"><![CDATA[继承的作用： 提高了代码的复用性。 让类与类之间产生了关系，有了这个关系，才有了多态的特性。 Java语言中，只支持单继承，不支持多继承 多继承容易带来安全隐患：当多个父类中定义了相同功能，功能的内容不同时，子类对象不确定要运行哪一个。但是Java保留了这种机制，并用另一种体现形式来完成表示：多实现。 Java支持多层继承，也就是一个继承体系。想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系中的共性功能，通过了解共性功能，就可以知道该体系的基本功能。那么这个体系就已经可以基本使用了。在具体调用时，要创建最下层子类的对象，为什么呢？一是因为有可能父类不能创建对象。二是创建子类对象可以使用更多的功能，包括基本的也包括特有的。简单一句话：查阅父类功能，创建子类对象。 子父类出现后，类中成员的特点：变量 如果子父类中出现非私有的同名成员变量时 子类要访问本类中的变量，用this，代表本类对象的引用 子类要访问父类中的同名变量，用super，代表父类对象的引用 子父类中的函数当子类中出现和父类一模一样的函数时，子类对象调用该函数，会运行子类中的函数，如同父类的函数被覆盖一样。这种情况是函数的另一个特性：重写（覆盖）。当子类继承父类，沿袭了父类的功能到子类中，但是子类虽具备了该功能，但是功能的内容却和父类不一致，这时没有必要定义新功能，而是使用覆盖特性，保留父类的功能定义，并重写功能内容。重写（覆盖）注意事项： 子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败。 静态只能覆盖静态。 成员变量、静态方法不能被重写（覆盖） 被覆盖的方法只有覆盖它们的类才能访问。 子父类中的构造函数在对子类对象进行初始化时，父类的构造函数也会运行，这是因为子类的构造函数默认第一行有一条隐式的语句super();super();会访问父类中空参数的构造函数，而且子类中所有的构造函数默认第一行都是super();为什么子类一定要访问父类中的构造函数呢？因为父类中的数据子类可以直接获取，所以子类对象在创建时，需要先查看父类是如何对这些数据进行初始化的，要先访问一下父类中的构造函数。如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。注意：super语句一定要定义在子类构造函数的第一行。super只有子类能用。 子类的实例化过程结论：当父类中没有空参数的构造函数时，子类必须手动通过super语句来指定要访问的构造函数。当然子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript垃圾回收机制(GC)]]></title>
    <url>%2F2016%2F07%2F25%2Fjavascript-gc%2F</url>
    <content type="text"><![CDATA[垃圾回收机制—GC 程序运行一定会涉及到内存的申请与释放和Java,c#一样，JavaScript也有垃圾回收的机制，早期的 C 语言( C++ )都手动的控制内存的申请与释放。在计算机中的内存不是一个固定, 属于 “流动型” 内存( 例如 公交车的座位 )，内存的管理决定了程序的运行效率。内存如果是连续的, 程序的运行效率高, 内存如果出现很多碎片, 程序运行的性能就低。 js 中凡是涉及到对象的时候 就会申请内存创建对象，调用函数，等操作都会涉及到申请内存。但是函数的内存由系统进行管理，一旦调用结束内存回收。但是对象的内存由 js 引擎进行管理，js 中对象具有动态特性，所以 js 引擎都会带有垃圾回收机制。垃圾回收做两件事儿，一个是释放不使用的内存， 二是整合内存。结论, 进行垃圾回收的时候, 会影响程序的性能 js 怎么进行回收, 什么时候进行回收呢?JavaScript垃圾回收的机制很简单：原理就是找出那些不再继续使用的变量，然后释放其占有内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。借用高程里面的一句话，你只需要记住 js 一定会回收，你相信它即可。在 js 中凡是不使用的对象才会被回收。var obj = {};在代码运行的过程中, 假设浏览器不关闭. 那么 这个对象( 右边的那个 ) 就不会被回收.如果代码运行了这么一句话:obj = null;那么这个对象就不再被引用着( 如果没有任何变量指向它 ), 这个对象就可以被回收。但是如果在 obj = null 之前执行了一句话 var newObj = obj，那么 obj 不再指向这个对象,但是 newObj 指向了这个对象, 即它不是 “幽灵”，这个对象依旧不会被回收。 常见的垃圾回收算法垃圾回收算法需要弄明白的问题有两个，一个是回收什么内存，二是什么时候回收 如何标记内存 引用计数法凡是对象, 在内存中会引用一个 count 指标, 如果对对象进行引用, 那么 count 就会自动 +1例如: 12345new Object(); // 此对象的 count 为 0 var o1 = new Object(); // 此对象的 count 为 1 var o2 = o1; // 该对象的 count 加 1，变为 2 o1 = &#123;&#125;; // 这个新对象的 count 为 1，原来的那个对象为 1 o2 = null; // 此时新对象的 count 还是 1，原来的那个对象就是 0 了，那么 它就可以释放了。 标记法凡是创建的对象都会获得一个标记，表示被引用者。在代码的运行机制中每一个变量会被创建一个索引，记录在系统的内部，可以类比成字典的索引。如果要进行回收，会遍历所有的变量索引，对应的去找这个对象在哪里，如果找到了对应的对象给对象加一个标记。如此遍历以后，我们的所有的对象就含有了对应的标记。在遍历对象所在的内存，将没有对应标记的对象找出来，表示这个内存可以被回收。 什么时候回收 定值域法在内存的使用过程中会监视每一个对象所占内存，以及总内存。会实时的与值域进行比较， 如果当这个数据超过了我们的值域，那么就会触发垃圾回收。 动态值域法给定上下限，同时监视程序的密集度。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题配置（二）]]></title>
    <url>%2F2016%2F05%2F11%2Fcreate-blog-02%2F</url>
    <content type="text"><![CDATA[引入第三方服务添加站内搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑根目录下的配置文件_config.yml，新增下面的内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 在next主题配置文件中启用本地搜索功能： 1234# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true 添加百度统计 登录 百度统计，注册站长账号，填写网站域名和网站首页，注册完成后并登陆。 复制 hm.js? 后面那串统计脚本 id,如下图所示： 在站点blog/_config.yml中修改字段 baidu_analytics，值设置成你的百度统计脚本 id。 添加网易云音乐就我所知目前也就网易云音乐和虾米音乐的外链播放器能用，网易云音乐很多好听的歌曲都不能生成外链，提示说是由于版权问题无法生成外链，而虾米音乐播放器外观实在是太那个了，所以只能用网易云音乐了，有些中文歌曲还是可以生成外链的。 首先进入官网后，搜索你要的歌曲，打开歌曲页面后左边唱盘图片下面有个“生成外链播放器”点进去，进去后可以看到有iframe和flash两种网易云音乐插件代码，还可以自定义播放器尺寸和自动播放。 将获得的html代码插入到你想要插入的位置。 我放在了侧边栏中，所以在next\layout\_macro\sidebar.swig文件中插入html代码即可 添加鼠标点击出现桃心下载love.js，将love.js文件放到next/source/js/src/文件夹中，在next/layout/_layout.swig文件的最下面引入即可:1&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题配置(一)]]></title>
    <url>%2F2016%2F05%2F11%2Fcreate-blog-01%2F</url>
    <content type="text"><![CDATA[本文只分享此博客的一些配置，对于node.js和github的安装可自行搜索，网上有很多教程。废话不多说，直接上代码。 基本配置：所需环境 Node 环境、 npm 全局安装 、github 账号 安装Hexo1234$ npm install hexo-cli -g #下载hexo$ hexo init blog #初始化$ cd blog$ hexo server #启动本地服务 此时打开浏览器，输入：http://localhost:4000/就能看到我们的博客了，但目前只有本机能看到，我们还需要将博客部署到github上：1$ hexo d -g 部署完成后输入我们的网址就可以访问了，如：spacesoldiers.github.io注意：每次修改博客内容后要重新部署。 next主题下载在blog根目录下执行：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载完成后，打开根目录下的配置文件_config.yml，找到 theme 字段，并将其值更改为 next theme: next 修改语言为中文：找到language字段 language: zh-Hans 选择schemeNext提供三种不同的外观，可以通过主题配置文件_config.yml更改外观，注意这是next主题文件夹里的文件，不是根目录配置文件。找到scheme字段，将需要使用的scheme前面的注释 # 去掉 # Schemes # scheme: Muse # scheme: Mist scheme: Pisces 设置菜单通过修改next主题下的_config.yml的menu字段，选定显示的菜单项。 menu: home: / categories: /categories/ archives: /archives/ about: /about/ #tags: /tags/ #sitemap: /sitemap.xml #commonweal: /404.html 添加菜单页面Next主题默认有home首页和archives归档页，因此新添加的菜单项需要新建菜单页面在根目录下输入命令：1$ hexo new page categories #添加分类页 在blog/source下会新生成一个新的文件夹categories，在该文件夹下会有一个index.md文件，添加内容type: &quot;categories&quot;12345---title: tagsdate: xxxx-xx-xxtype: "categories"--- 要为某一篇文章添加分类，只需在blog/source/_post目录下的具体文章的categories中添加分类名称即可，如：12345---title: "前端学习路线"tags: "学习路径"categories: "前端"--- 其他菜单页的添加同理，这里不再一一介绍。 头像设置在next主题文件的source/images/下放置头像文件avatar.gif即可 设置favicon.ico将设计好的图标放入source/images/文件中，在主题配置文件中找到favicon字段 favicon: images/favicon.ico 设置代码主题NexT共有5款代码主题供你选择，更改 highlight_theme 字段，将其值设定成你所喜爱的主题 # Code Highlight theme # Available value: normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: normal 自定义css样式是否觉得主题的某些样式不符合自己的心意，不用担心，next的设计还是很人性化的，你可以自己定义喜欢的样式，你所有的css改动需要放在主题文件的source/css/_costum/costum.styl文件中，会覆盖原来的css，这样比你修改源文件要好的多，不想用时只要删除掉costum.styl里面自己写的代码，就会回到原来的样子。 添加logo图片可以从网上免费设计一个logo图片，存放到source/images/文件夹中，在costum.styl中给.site-meta .brand添加背景图片样式即可，如：1background-image: url(&quot;/images/logo.png&quot;); 去除底部copyright将主题配置文件中的copyright字段值改为false即可。12# Footer `powered-by` and `theme-info` copyrightcopyright: false 添加页面加载动画next配置文件中有很多种页面加载动画可供选择，找到pace字段改为true，然后选择一个自己喜欢的样式：12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-bounce 自定义菜单栏动画由于next主题已经引入了velocity.js，所以直接用它的动画就可以了，找到next/layout/_layout.swig，在body最下面添加代码:12345&#123;% if theme.menu_move.enable %&#125; &lt;script&gt; $(".menu-item").stop(true).velocity("transition.slideLeftBigIn", &#123; stagger: 200 &#125;); &lt;/script&gt;&#123;% endif %&#125; 在主题配置文件中加入字段menu_move:12menu_move: enable: true 配置完成后发现自定义动画结束后，还会执行一次动画，那是因为菜单栏有自带的动画，这里需要去除一下，找到next/source/js/src/bootstrap.js，将第31行和第37行注释掉即可：12// NexT.utils.addActiveClassToMenuItem();// .add(NexT.motion.middleWares.menu)]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大前端学习路线]]></title>
    <url>%2F2016%2F04%2F25%2Fstudypath%2F</url>
    <content type="text"><![CDATA[第一阶段：基础教程HTML+CSS: HTML进阶、CSS进阶、div+css布局、HTML+css开发 JavaScript基础： js基础教程、js内置对象、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器 JS基本特效： 常见特效：tab栏切换、导航、整页滚动、轮播图、手风琴菜单、瀑布流布局、滚动事件… JS高级： 正则表达式、排序算法、递归算法、闭包、作用域链、面向对象基础… JQuery：基础使用 DOM操作、特效和动画、方法链、JQueryUI组件基本使用… 第二阶段：HTML5和移动Web开发HTML5： HTML5新语义标签、html5表单、音频和视频、离线和本地存储、canvas. CSS3: CSS3新选择器、伪元素、边框、阴影、background系列属性、transition、动画、3D效果制作、velocity.js、css3网页制作 Bootstrap: 响应式概念、媒体查询、响应式网站制作、删格系统、Bootstrap常用模板、LESS和SASS 移动Web开发： 跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、zepto.js 第三阶段：HTTP服务和AJAX编程WEB服务器基础： 服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍 PHP基础： PHP基础语法、使用php处理简单的GET或者POST请求 AJAX： Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用 JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、jQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额 第四阶段：面向对象面向对象三大特征： 抽象性、继承性、多态性、封装性 设计模式： 面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程 第五阶段：框架封装框架封装基础： 事件冒泡、捕获、事件对象 框架封装中级： 运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装 框架封装高级和补充： jquery框架雏形、可扩展性、模块化、封装属于传智自己的框架 第六阶段：模块化组件开发面向组件编程： 面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。 面向模块编程： AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS 第七阶段：主流框架Web开发工作流： Git/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack MVC/MVVM/MVW框架： Angular.js、Backbone.js、Knockout/Ember 常用库： React.js、Vue.js、Zepto.js。 第八阶段：HTML5原生移动应用开发Cordova： WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。 Ionic： Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。 React Native： react Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。 HTML5+： Html5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。 第九阶段： Node.js全栈开发：快速入门： Node.js发展、生态圈、Io.js、Linux/Windows/OS X环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试核心模块和对象： 全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端、Socket.IO Web开发基础： HTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例 快速开发框架： Express简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>学习目标</tag>
      </tags>
  </entry>
</search>